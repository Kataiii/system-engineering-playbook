<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ADR - system-engineering-playbook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/_assets/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">system-engineering-playbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://docs.google.com/document/d/1NnZB57I-WnOwblDwLx0j21prRAXQAPoZ6eFcLpOHcyk/edit?usp=sharing">Ссылка на документ</a></p>
<h1 id="adr-flutter"><a class="header" href="#adr-flutter">ADR Flutter</a></h1>
<h1 id="adr-Выбор-dart-и-flutter-с-движком-рендеринга-impeller-для-разработки-мобильного-приложения"><a class="header" href="#adr-Выбор-dart-и-flutter-с-движком-рендеринга-impeller-для-разработки-мобильного-приложения"><strong>ADR: Выбор Dart и Flutter с движком рендеринга Impeller для разработки мобильного приложения</strong></a></h1>
<h2 id="Контекст"><a class="header" href="#Контекст"><strong>Контекст</strong></a></h2>
<p>Требуется разработать кроссплатформенное мобильное приложение для iOS и Android со следующими характеристиками:</p>
<ul>
<li>Обязательное требование: Единая кодовая база для всех платформ</li>
<li>Обязательное требование: Идентичный интерфейс и пользовательский опыт на iOS и Android</li>
<li>Срок выхода на рынок: 6 месяцев</li>
<li>Целевая аудитория: 50K+ пользователей</li>
<li>Требования к производительности: стабильный UI 60fps без шейдерных дропов</li>
<li>Бюджет: ограниченный</li>
</ul>
<h2 id="Ключевые-требования-из-ТЗ"><a class="header" href="#Ключевые-требования-из-ТЗ"><strong>Ключевые требования из ТЗ</strong></a></h2>
<ol>
<li>Единая кодовая база - один код для iOS и Android</li>
<li>Идентичный интерфейс - одинаковый UI и UX на всех платформах</li>
<li>Консистентность бренда - точное соблюдение дизайн-системы</li>
<li>Синхронные обновления - одновременный релиз фич на всех платформах</li>
</ol>
<h2 id="Рассмотренные-варианты"><a class="header" href="#Рассмотренные-варианты"><strong>Рассмотренные варианты</strong></a></h2>
<h3 id="Вариант-1-Нативная-разработка-swiftkotlin"><a class="header" href="#Вариант-1-Нативная-разработка-swiftkotlin"><strong>Вариант 1: Нативная разработка (Swift/Kotlin)</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Максимальная производительность</li>
<li>Прямой доступ к нативным API</li>
<li>Стабильность и зрелость экосистем</li>
</ul>
<p>Минусы:</p>
<ul>
<li>❌ Две отдельные codebase - нарушение ключевого требования</li>
<li>❌ Разный UI - нативные компоненты iOS/Android отличаются визуально</li>
<li>Удвоенные затраты на разработку</li>
<li>Сложность синхронизации фич между платформами</li>
<li>Различное поведение жестов и анимаций</li>
</ul>
<h3 id="Вариант-2-react-native"><a class="header" href="#Вариант-2-react-native"><strong>Вариант 2: React Native</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Широкая популярность и сообщество</li>
<li>Использование JavaScript/TypeScript</li>
<li>Большое количество готовых библиотек</li>
</ul>
<p>Минусы:</p>
<ul>
<li>⚠️ Частично единая codebase - требует нативных модулей</li>
<li>⚠️ Визуальные различия - компоненты могут выглядеть по-разному</li>
<li>Мост между нативным и JS кодом создает bottleneck</li>
<li>Проблемы с компиляцией шейдеров в рантайме</li>
<li>Задержки при сложных анимациях</li>
</ul>
<h3 id="Вариант-3-flutter-с-impeller-dart"><a class="header" href="#Вариант-3-flutter-с-impeller-dart"><strong>Вариант 3: Flutter с Impeller (Dart)</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>✅ Полностью единая codebase для обеих платформ</li>
<li>✅ Абсолютно идентичный UI - пиксель в пиксель совпадение</li>
<li>Предсказуемая производительность с предкомпиляцией шейдеров</li>
<li>Современный движок рендеринга, оптимизированный для мобильных устройств</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Относительно новый движок рендеринга</li>
<li>Требует Flutter 3.10+ для полной функциональности</li>
</ul>
<h2 id="Решение"><a class="header" href="#Решение"><strong>Решение</strong></a></h2>
<p>Выбран Вариант 3: Flutter с языком Dart и движком рендеринга Impeller</p>
<h3 id="Обоснование-соответствия-требованиям-ТЗ"><a class="header" href="#Обоснование-соответствия-требованиям-ТЗ"><strong>Обоснование соответствия требованиям ТЗ</strong></a></h3>
<h4 id="1-Единая-кодовая-база---100-выполнение"><a class="header" href="#1-Единая-кодовая-база---100-выполнение"><strong>1. Единая кодовая база - 100% выполнение</strong></a></h4>
<p>Реализация требования:</p>
<ul>
<li>Один репозиторий кода</li>
<li>Один процесс разработки</li>
<li>Один pipeline CI/CD</li>
<li>Исключение дублирования логики</li>
</ul>
<h4 id="2-Идентичный-интерфейс---гарантированное-визуальное-соответствие"><a class="header" href="#2-Идентичный-интерфейс---гарантированное-визуальное-соответствие"><strong>2. Идентичный интерфейс - гарантированное визуальное соответствие</strong></a></h4>
<p>Преимущества для консистентности:</p>
<ul>
<li>✅ Точное соблюдение дизайн-системы</li>
<li>✅ Идентичные анимации и transitions</li>
<li>✅ Одинаковые жесты и интерактивность</li>
<li>✅ Совпадение pixel-perfect макетов</li>
</ul>
<h4 id="3-Сравнение-выполнения-требований-ТЗ"><a class="header" href="#3-Сравнение-выполнения-требований-ТЗ"><strong>3. Сравнение выполнения требований ТЗ</strong></a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Требование ТЗ</th><th style="text-align: left">Нативный</th><th style="text-align: left">React Native</th><th style="text-align: left">Flutter + Impeller</th></tr></thead><tbody>
<tr><td style="text-align: left">Единая кодовая база</td><td style="text-align: left">❌ Не выполняется</td><td style="text-align: left">⚠️ Частично</td><td style="text-align: left">✅ Полностью</td></tr>
<tr><td style="text-align: left">Идентичный интерфейс</td><td style="text-align: left">❌ Не выполняется</td><td style="text-align: left">⚠️ Частично</td><td style="text-align: left">✅ Полностью</td></tr>
<tr><td style="text-align: left">Консистентность бренда</td><td style="text-align: left">❌ Сложно</td><td style="text-align: left">⚠️ Возможно</td><td style="text-align: left">✅ Гарантировано</td></tr>
<tr><td style="text-align: left">Синхронные обновления</td><td style="text-align: left">❌ Сложно</td><td style="text-align: left">⚠️ Возможно</td><td style="text-align: left">✅ Автоматически</td></tr>
</tbody></table>
</div>
<h4 id="4-Экономическая-эффективность-при-выполнении-ТЗ"><a class="header" href="#4-Экономическая-эффективность-при-выполнении-ТЗ"><strong>4. Экономическая эффективность при выполнении ТЗ</strong></a></h4>
<p><code>Оценка выполнения требований ТЗ:</code><br />
<code>- Нативная разработка: 24 человеко-месяца + постоянная синхронизация UI</code><br />
<code>- React Native: 14 человеко-месяцев + доработка консистентности</code><br />
<code>- Flutter + Impeller: 12 человеко-месяцев (автоматическая консистентность)</code></p>
<h2 id="Последствия"><a class="header" href="#Последствия"><strong>Последствия</strong></a></h2>
<h3 id="Положительные"><a class="header" href="#Положительные"><strong>Положительные</strong></a></h3>
<ul>
<li>✅ 100% выполнение требований ТЗ по единой codebase и идентичному UI</li>
<li>Стабильная производительность с Impeller - отсутствие шейдерных компиляций</li>
<li>Автоматическая консистентность - визуальная идентичность гарантирована архитектурой</li>
<li>Сокращение времени разработки на 40%</li>
<li>Экономия бюджета на разработку ~$120K</li>
<li>Future-proof архитектура - Impeller как стратегическое направление Flutter</li>
</ul>
<h3 id="Отрицательные"><a class="header" href="#Отрицательные"><strong>Отрицательные</strong></a></h3>
<ul>
<li>Отказ от нативных паттернов - одинаковый UI может отличаться от ожиданий пользователей конкретной платформы</li>
<li>Ограниченная обратная совместимость: Требует Flutter 3.10+</li>
<li>Меньше документации по Impeller compared to Skia</li>
</ul>
<h3 id="Риски-и-митигация"><a class="header" href="#Риски-и-митигация"><strong>Риски и митигация</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Риск</th><th style="text-align: left">Вероятность</th><th style="text-align: left">Влияние</th><th style="text-align: left">Митигация</th></tr></thead><tbody>
<tr><td style="text-align: left">Единый UI не соответствует ожиданиям пользователей</td><td style="text-align: left">Средняя</td><td style="text-align: left">Среднее</td><td style="text-align: left">UX исследования, опциональная адаптация под платформу</td></tr>
<tr><td style="text-align: left">Регрессии в Impeller</td><td style="text-align: left">Средняя</td><td style="text-align: left">Высокое</td><td style="text-align: left">Тестирование на реальных устройствах, fallback на Skia</td></tr>
<tr><td style="text-align: left">Ограниченная функциональность</td><td style="text-align: left">Низкая</td><td style="text-align: left">Среднее</td><td style="text-align: left">Мониторинг обновлений Impeller</td></tr>
</tbody></table>
</div>
<h2 id="Заключение"><a class="header" href="#Заключение"><strong>Заключение</strong></a></h2>
<p>Flutter с Impeller является оптимальным выбором, полностью соответствующим всем требованиям ТЗ:</p>
<ol>
<li>✅ Единая кодовая база - один код для iOS и Android</li>
<li>✅ Идентичный интерфейс - pixel-perfect совпадение на всех платформах</li>
<li>✅ Консистентность бренда - точное соблюдение дизайн-системы</li>
<li>✅ Синхронные обновления - одновременный релиз на всех платформах</li>
</ol>
<p>Дополнительные преимущества:</p>
<ul>
<li>Стабильная производительность с предкомпиляцией шейдеров Impeller</li>
<li>Экономическая эффективность разработки</li>
</ul>
<p>Данное решение не только соответствует текущим требованиям ТЗ, но и создает основу для масштабирования на другие платформы (web, desktop) с сохранением полной консистентности кодовой базы и пользовательского интерфейса.</p>
<h1 id="adr-МП"><a class="header" href="#adr-МП">ADR МП</a></h1>
<h3 id="adr-Архитектура-приложения--clean-architecture-Контекст-Требуется-создать-сложное-мобильное-приложение-с-четким-разделением-ответственности-высокой-тестируемостью-независимостью-от-фреймворков-и-ui-а-также-поддержкой-нескольких-источников-данных-локальная-БД-ИИ-внешние-api-Приложение-должно-быть-легко-масштабируемым-и-поддерживаемым-в-долгосрочной-перспективе"><a class="header" href="#adr-Архитектура-приложения--clean-architecture-Контекст-Требуется-создать-сложное-мобильное-приложение-с-четким-разделением-ответственности-высокой-тестируемостью-независимостью-от-фреймворков-и-ui-а-также-поддержкой-нескольких-источников-данных-локальная-БД-ИИ-внешние-api-Приложение-должно-быть-легко-масштабируемым-и-поддерживаемым-в-долгосрочной-перспективе"><strong>ADR: Архитектура приложения — Clean Architecture</strong> Контекст: Требуется создать сложное мобильное приложение с четким разделением ответственности, высокой тестируемостью, независимостью от фреймворков и UI, а также поддержкой нескольких источников данных (локальная БД, ИИ, внешние API). Приложение должно быть легко масштабируемым и поддерживаемым в долгосрочной перспективе.</a></h3>
<p>Решение: Использовать Clean Architecture. Структура проекта будет разделена на три основных слоя:</p>
<ol>
<li>Presentation Layer (Слой представления): Содержит виджеты, страницы и логику состояния (BLoC). Зависит от Domain Layer.</li>
<li>Domain Layer (Доменный слой): Содержит бизнес-логику, Use Cases (Интеракторы), Entities (Бизнес-сущности) и интерфейсы репозиториев. Это ядро приложения, которое не зависит ни от каких внешних фреймворков.</li>
<li>Data Layer (Слой данных): Содержит реализацию репозиториев, модели данных (Data Transfer Objects - DTOs), источники данных (локальная БД, сетевые API). Зависит от Domain Layer.</li>
</ol>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Тестируемость: Бизнес-логика (Use Cases) и логика состояния (BLoC) могут быть легко протестированы с помощью модульных тестов, так как не зависят от конкретных реализаций UI, БД или сети.</li>
<li>Слабая связанность: Изменения в одном слое (например, замена Hive на другую БД) минимально затрагивают другие слои.</li>
<li>Сопровождаемость: Четкое разделение кода облегчает его понимание и модификацию, что соответствует требованию поддержки и обслуживания.</li>
<li>Масштабируемость: Новые функции (например, интеграция с новым фитнес-сервисом) легко добавляются в виде новых Use Cases и репозиториев.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Бойлерплейт: Требуется писать больше кода для организации слоев и преобразования моделей между ними.</li>
<li>Сложность изучения: Для новых разработчиков может показаться избыточно сложной по сравнению с MVC или простым StatefulWidget.</li>
</ul>
</li>
</ul>
<h3 id="adr-Управление-состоянием--bloc-Контекст-Приложение-имеет-сложное-состояние-асинхронная-загрузка-данных-от-ИИ-пошаговый-процесс-тренировки-с-таймерами-множественные-экраны-с-фильтрами-и-поиском-Необходимо-централизованно-управлять-состоянием-обеспечивать-предсказуемость-его-изменений-и-легко-тестировать-логику"><a class="header" href="#adr-Управление-состоянием--bloc-Контекст-Приложение-имеет-сложное-состояние-асинхронная-загрузка-данных-от-ИИ-пошаговый-процесс-тренировки-с-таймерами-множественные-экраны-с-фильтрами-и-поиском-Необходимо-централизованно-управлять-состоянием-обеспечивать-предсказуемость-его-изменений-и-легко-тестировать-логику"><strong>ADR: Управление состоянием — BLoC</strong> Контекст: Приложение имеет сложное состояние: асинхронная загрузка данных от ИИ, пошаговый процесс тренировки с таймерами, множественные экраны с фильтрами и поиском. Необходимо централизованно управлять состоянием, обеспечивать предсказуемость его изменений и легко тестировать логику.</a></h3>
<p>Решение: Использовать библиотеку BLoC (Business Logic Component). BLoC будет выступать в качестве прослойки между Domain Layer (Use Cases) и Presentation Layer.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Предсказуемость: Односторонний поток данных (Events -&gt; Bloc -&gt; State) делает отладку и отслеживание изменений состояния простым.</li>
<li>Мощная экосистема: Интеграция с <code>bloc_test</code> для простого тестирования, <code>flutter_bloc</code> для удобной работы с виджетами.</li>
<li>Отличное разделение логики и UI: BLoC изолирует бизнес-логику, что идеально сочетается с Clean Architecture. UI просто отображает состояние и отправляет события.</li>
<li>Поддержка сложных сценариев: Отлично подходит для обработки асинхронных операций (генерация ИИ, таймеры тренировки), что критично для нашего приложения.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Кривая обучения: Требует понимания концепций Streams, Rx.</li>
<li>Бойлерплейт: Необходимо создавать классы для Events, States и самих Blocs даже для простых операций.</li>
</ul>
</li>
</ul>
<h3 id="adr-Внедрение-зависимостей--injectable--get-it-Контекст-В-clean-architecture-с-множеством-слоев-и-зависимостей-репозитории-use-cases-внешние-сервисы-необходим-эффективный-и-безопасный-способ-представления-этих-зависимостей-классам-которые-в-них-нуждаются-например-bloc-ам"><a class="header" href="#adr-Внедрение-зависимостей--injectable--get-it-Контекст-В-clean-architecture-с-множеством-слоев-и-зависимостей-репозитории-use-cases-внешние-сервисы-необходим-эффективный-и-безопасный-способ-представления-этих-зависимостей-классам-которые-в-них-нуждаются-например-bloc-ам"><strong>ADR: Внедрение зависимостей — Injectable + Get It</strong> Контекст: В Clean Architecture с множеством слоев и зависимостей (репозитории, use cases, внешние сервисы) необходим эффективный и безопасный способ представления этих зависимостей классам, которые в них нуждаются (например, BLoC-ам).</a></h3>
<p>Решение: Использовать комбинацию injectable (генератор кода на основе аннотаций) и get_it (контейнер служб). Это позволит автоматически генерировать код для регистрации и разрешения зависимостей.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Минимум ручного кода: <code>injectable</code> генерирует код регистрации зависимостей, что уменьшает количество ошибок и бойлерплейта.</li>
<li>Типобезопасность: <code>get_it</code> обеспечивает типобезопасное получение зависимостей.</li>
<li>Простота тестирования: Позволяет легко подменять реальные реализации на Mock-объекты во время тестов.</li>
<li>Чистота архитектуры: Помогает соблюдать принцип Dependency Inversion, объявляя зависимости в Domain Layer через абстракции (интерфейсы), а реализацию предоставляя в Data Layer.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Зависимость от кодогенерации: Требует периодического запуска <code>build_runner</code>.</li>
<li>Неочевидно откуда и как берутся зависимости.</li>
</ul>
</li>
</ul>
<h3 id="adr-Локальная-база-данных--hive-Контекст-Приложению-необходимо-хранить-большое-количество-структурированных-данных-локально-профиль-пользователя-шаблоны-тренировок-историю-выполненных-тренировок-упражнения-Требуется-высокая-производительность-для-операций-чтениязаписи-особенно-во-время-активной-тренировки-Критически-важен-оффлайн-режим"><a class="header" href="#adr-Локальная-база-данных--hive-Контекст-Приложению-необходимо-хранить-большое-количество-структурированных-данных-локально-профиль-пользователя-шаблоны-тренировок-историю-выполненных-тренировок-упражнения-Требуется-высокая-производительность-для-операций-чтениязаписи-особенно-во-время-активной-тренировки-Критически-важен-оффлайн-режим"><strong>ADR: Локальная база данных — Hive</strong> Контекст: Приложению необходимо хранить большое количество структурированных данных локально: профиль пользователя, шаблоны тренировок, историю выполненных тренировок, упражнения. Требуется высокая производительность для операций чтения/записи, особенно во время активной тренировки. Критически важен оффлайн-режим.</a></h3>
<p>Решение: Использовать Hive как основное решение для локального хранения данных. Это NoSQL-база данных, написанная на Dart, очень быстрая и не требующая ORM.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Высокая производительность: Значительно быстрее SQLite, так как не использует SQL-запросы и ORM.</li>
<li>Простота использования: Не требует описания схемы на SQL, работа ведется с нативными Dart-объектами (после их адаптации с помощью <code>TypeAdapter</code>).</li>
<li>Кросс-платформенность: Работает на всех платформах Flutter.</li>
<li>Идеально для оффлайн-режима: Быстрый доступ к данным удовлетворяет требованию работы без интернета.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Отсутствие схемы и сложных запросов: Не подходит для данных, требующих сложных JOIN-запросов. Однако для структуры данных приложения (тренировки, упражнения) это не является проблемой.</li>
</ul>
</li>
</ul>
<h3 id="adr-Шифрование-локальных-данных--flutter-secure-storage-Контекст-Согласно-нефункциональному-требованию-Безопасность-необходимо-обеспечить-шифрование-локально-хранимых-пользовательских-данных-Пнд-Обычные-boxes-hive-не-шифруются-по-умолчанию"><a class="header" href="#adr-Шифрование-локальных-данных--flutter-secure-storage-Контекст-Согласно-нефункциональному-требованию-Безопасность-необходимо-обеспечить-шифрование-локально-хранимых-пользовательских-данных-Пнд-Обычные-boxes-hive-не-шифруются-по-умолчанию"><strong>ADR: Шифрование локальных данных — Flutter Secure Storage</strong> Контекст: Согласно нефункциональному требованию "Безопасность", необходимо обеспечить шифрование локально хранимых пользовательских данных (Пн.д.). Обычные Boxes Hive не шифруются по умолчанию.</a></h3>
<p>Решение: Использовать пакет flutter_secure_storage для хранения мастер-ключа от зашифрованного Hive-бокса. Это позволит создать зашифрованное хранилище для конфиденциальных данных пользователя.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Безопасность: Ключи хранятся в защищенных хранилищах платформ (Keychain для iOS, Keystore для Android).</li>
<li>Соответствие требованиям: Позволяет выполнить требование по шифрованию Пн.д.</li>
<li>Интеграция с Hive: Hive предоставляет возможность использовать зашифрованные боксы, инициализируемые с помощью ключа из Secure Storage.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Дополнительная сложность: Необходимо управлять процессом инициализации зашифрованного бокса при запуске приложения.</li>
</ul>
</li>
</ul>
<h3 id="adr-Локальные-уведомления--flutter-local-notifications-Контекст-Требуется-отправлять-push-уведомления-даже-когда-приложение-закрыто-например-для-мотивационных-сообщений-напоминаний-о-тренировках-или-уведомления-о-завершении-таймера-отдыха-сценарий-Пользователь-забыл-завершить-тренировку"><a class="header" href="#adr-Локальные-уведомления--flutter-local-notifications-Контекст-Требуется-отправлять-push-уведомления-даже-когда-приложение-закрыто-например-для-мотивационных-сообщений-напоминаний-о-тренировках-или-уведомления-о-завершении-таймера-отдыха-сценарий-Пользователь-забыл-завершить-тренировку"><strong>ADR: Локальные уведомления — Flutter Local Notifications</strong> Контекст: Требуется отправлять push-уведомления даже когда приложение закрыто, например, для мотивационных сообщений, напоминаний о тренировках или уведомления о завершении таймера отдыха (сценарий "Пользователь забыл завершить тренировку").</a></h3>
<p>Решение: Использовать пакет flutter_local_notifications. Он предоставляет богатый функционал для отображения локальных уведомлений на iOS и Android.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Контроль: Уведомления планируются и показываются самим приложением, без необходимости в серверной части.</li>
<li>Гибкость: Позволяет создавать уведомления с действиями (actions), что полезно для быстрых ответов.</li>
<li>Оффлайн-работа: Полностью работает без интернета.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Платформенная специфика: Требует настройки разрешений и каналов уведомлений для каждой платформы.</li>
</ul>
</li>
</ul>
<h3 id="adr-Живые-активности--live-activities--activitykit-Контекст-В-сценарии-Процесс-тренировки-требуется-отображать-нескрываемый-action-push-с-прогрессом-выполнения-упражнения-На-ios-начиная-с-версии-161-для-этого-идеально-подходят-live-activities"><a class="header" href="#adr-Живые-активности--live-activities--activitykit-Контекст-В-сценарии-Процесс-тренировки-требуется-отображать-нескрываемый-action-push-с-прогрессом-выполнения-упражнения-На-ios-начиная-с-версии-161-для-этого-идеально-подходят-live-activities"><strong>ADR: "Живые" активности — Live Activities / ActivityKit</strong> Контекст: В сценарии "Процесс тренировки" требуется отображать "нескрываемый action-push с прогрессом выполнения упражнения". На iOS, начиная с версии 16.1, для этого идеально подходят Live Activities.</a></h3>
<p>Решение: Использовать пакет live_activities (или написать нативный плагин) для интеграции с iOS ActivityKit. Это позволит выводить информацию о текущей тренировке на экран блокировки и в " Dynamic Island".</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Инновационный UI: Предоставляет пользователю лучший в своем классе опыт, соответствуя современным тенденциям iOS.</li>
<li>Постоянная видимость: Ключевая информация о тренировке всегда под рукой, не занимая место в основном интерфейсе.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Только для iOS 16.1+: Охват пользователей ограничен. Для Android и старых версий iOS потребуется альтернативная реализация (например, постоянное уведомление).</li>
<li>Сложность реализации: Требует глубокого понимания нативных возможностей iOS и Swift.</li>
</ul>
</li>
</ul>
<h3 id="adr-Локальный-ИИ--google-ml-kit-Контекст-ИИ-тренер-должен-генерировать-тренировки-и-давать-рекомендации-Для-обеспечения-конфиденциальности-данных-скорости-работы-и-оффлайн-функциональности-критически-важно-выполнять-часть-вычислений-на-устройстве"><a class="header" href="#adr-Локальный-ИИ--google-ml-kit-Контекст-ИИ-тренер-должен-генерировать-тренировки-и-давать-рекомендации-Для-обеспечения-конфиденциальности-данных-скорости-работы-и-оффлайн-функциональности-критически-важно-выполнять-часть-вычислений-на-устройстве"><strong>ADR: Локальный ИИ — Google ML Kit</strong> Контекст: ИИ-тренер должен генерировать тренировки и давать рекомендации. Для обеспечения конфиденциальности данных, скорости работы и оффлайн-функциональности критически важно выполнять часть вычислений на устройстве.</a></h3>
<p>Решение: Использовать Google ML Kit. В частности, его возможности для Natural Language Processing (NLP) (например, для анализа целей пользователя, если они вводятся текстом) и Custom Models. Мы можем обучить собственную модель для рекомендаций упражнений и развернуть ее на устройстве с помощью ML Kit.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Конфиденциальность: Данные пользователя не покидают его устройство.</li>
<li>Оффлайн-работа: ИИ функциональность доступна без интернета.</li>
<li>Производительность: Быстрый отклик, нет задержек на сетевой запрос.</li>
<li>Кросс-платформенность: Работает на iOS и Android.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Ограниченная мощность: Модели на устройстве обычно менее мощные, чем большие серверные модели (как GPT). Требуется тщательное проектирование и обучение модели для достижения качественных результатов.</li>
<li>Размер приложения: Включение моделей может увеличить размер APK/IPA.</li>
</ul>
</li>
</ul>
<h3 id="adr-Связь-со-смарт-часами--watch-connectivity--flutter-wear-plugin-Контекст-Для-расширения-пользовательского-опыта-и-сбора-более-точных-данных-пульс-желательна-интеграция-со-смарт-часами-Это-позволит-управлять-тренировкой-и-видеть-прогресс-прямо-на-запястье"><a class="header" href="#adr-Связь-со-смарт-часами--watch-connectivity--flutter-wear-plugin-Контекст-Для-расширения-пользовательского-опыта-и-сбора-более-точных-данных-пульс-желательна-интеграция-со-смарт-часами-Это-позволит-управлять-тренировкой-и-видеть-прогресс-прямо-на-запястье"><strong>ADR: Связь со смарт-часами — Watch Connectivity / Flutter Wear Plugin</strong> Контекст: Для расширения пользовательского опыта и сбора более точных данных (пульс) желательна интеграция со смарт-часами. Это позволит управлять тренировкой и видеть прогресс прямо на запястье.</a></h3>
<p>Решение: Использовать нативные API (WatchConnectivity для iOS, Wear OS APIs для Android) через кастомный плагин или готовые решения, такие как flutter_apple_watch или wear.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Улучшенный UX: Пользователи могут оставить телефон в стороне и управлять тренировкой с часов.</li>
<li>Дополнительные данные: Интеграция с датчиками часов (пульс) для более точного анализа нагрузки и рекомендаций по отдыху.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Высокая сложность: Требуется разработка и поддержка двух отдельных приложений/интерфейсов (для телефона и для часов).</li>
<li>Фрагментация: Необходимо учитывать различия между WatchOS и Wear OS.</li>
</ul>
</li>
</ul>
<h3 id="adr-Проверка-подключения-к-интернету--connectivity-plus-Контекст-Приложению-необходимо-определять-состояние-сетевого-подключения-для-включенияотключения-определенных-функций-например-синхронизация-с-календарем-обновление-облачной-аналитики-и-для-информирования-пользователя"><a class="header" href="#adr-Проверка-подключения-к-интернету--connectivity-plus-Контекст-Приложению-необходимо-определять-состояние-сетевого-подключения-для-включенияотключения-определенных-функций-например-синхронизация-с-календарем-обновление-облачной-аналитики-и-для-информирования-пользователя"><strong>ADR: Проверка подключения к интернету — Connectivity Plus</strong> Контекст: Приложению необходимо определять состояние сетевого подключения для включения/отключения определенных функций (например, синхронизация с календарем, обновление облачной аналитики) и для информирования пользователя.</a></h3>
<p>Решение: Использовать пакет connectivity_plus. Он предоставляет простой API для проверки типа подключения (Wi-Fi, мобильное) и его наличия.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Простота использования: Легко интегрируется в BLoC для реакции на изменение состояния сети.</li>
<li>Кросс-платформенность.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Ограниченность: Проверяет только наличие подключения, но не факт наличия интернета (устройство может быть в Wi-Fi без доступа в сеть). Для точной проверки может потребоваться дополнительный ping-запрос.</li>
</ul>
</li>
</ul>
<h3 id="adr-Сетевые-запросы--retrofit--dio-Контекст-Для-взаимодействия-с-внешними-api-например-для-синхронизации-с-google-calendar-отправки-аналитики-на-сервер-потенциально-для-облачной-версии-ИИ-необходим-мощный-и-удобный-http-клиент"><a class="header" href="#adr-Сетевые-запросы--retrofit--dio-Контекст-Для-взаимодействия-с-внешними-api-например-для-синхронизации-с-google-calendar-отправки-аналитики-на-сервер-потенциально-для-облачной-версии-ИИ-необходим-мощный-и-удобный-http-клиент"><strong>ADR: Сетевые запросы — Retrofit + Dio</strong> Контекст: Для взаимодействия с внешними API (например, для синхронизации с Google Calendar, отправки аналитики на сервер, потенциально для облачной версии ИИ) необходим мощный и удобный HTTP-клиент.</a></h3>
<p>Решение: Использовать комбинацию Dio (как HTTP-клиент) и Retrofit (как генератор кода для API-клиентов). Retrofit позволит описать API в виде аннотированного Dart-интерфейса, что сделает сетевой слой чистым и типобезопасным.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Минимум бойлерплейта: Retrofit генерирует весь код для сетевых вызовов.</li>
<li>Типобезопасность: Ошибки в путях запросов или телах ловятся на этапе компиляции.</li>
<li>Мощность Dio: Перехватчики (interceptors) для логирования, кеширования, автоматических повторов запросов, что упрощает обработку ошибок и соответствует требованию по аналитике сбоев.</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Зависимость от кодогенерации.</li>
</ul>
</li>
</ul>
<h1 id="adr-nestjs"><a class="header" href="#adr-nestjs">ADR NestJS</a></h1>
<h1 id="adr-Выбор-nestjs-для-разработки-backend-мобильного-приложения-дневника-тренировок-с-ИИ-тренером"><a class="header" href="#adr-Выбор-nestjs-для-разработки-backend-мобильного-приложения-дневника-тренировок-с-ИИ-тренером"><strong>ADR: Выбор NestJS для разработки backend мобильного приложения-дневника тренировок с ИИ-тренером</strong></a></h1>
<h2 id="Контекст-1"><a class="header" href="#Контекст-1"><strong>Контекст</strong></a></h2>
<p>Согласно ТЗ требуется разработать backend для мобильного приложения-дневника тренировок с ИИ-тренером. Основные требования из ТЗ:</p>
<p>Функциональные требования:</p>
<ul>
<li>Управление тренировочными процессами и программами</li>
<li>Интеграция с ИИ-тренером для генерации тренировок</li>
<li>Синхронизация данных между устройствами</li>
<li>Управление пользовательскими профилями и данными</li>
<li>Обработка оффлайн-данных при синхронизации</li>
<li>Интеграция с календарями (Google Calendar, системные календари)</li>
</ul>
<p>Нефункциональные требования из ТЗ:</p>
<ul>
<li>Безопасность: шифрование данных, соответствие 152-ФЗ</li>
<li>Поддержка оффлайн-режима с последующей синхронизацией</li>
<li>Надежность: не более 1 критической ошибки на 1000 сессий</li>
<li>Совместимость с iOS 14+, Android 10+, HarmonyOS</li>
<li>Возможность удаленного обновления контента</li>
</ul>
<h2 id="Рассмотренные-варианты-1"><a class="header" href="#Рассмотренные-варианты-1"><strong>Рассмотренные варианты</strong></a></h2>
<h3 id="Вариант-1-django-python"><a class="header" href="#Вариант-1-django-python"><strong>Вариант 1: Django (Python)</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Богатая экосистема для ML (ИИ-тренер)</li>
<li>Встроенная админ-панель</li>
<li>ORM из коробки</li>
<li>Зрелое сообщество</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Менее производительный в I/O операциях</li>
<li>Сложности с real-time функциями</li>
<li>Больший расход памяти</li>
</ul>
<h3 id="Вариант-2-spring-boot-javakotlin"><a class="header" href="#Вариант-2-spring-boot-javakotlin"><strong>Вариант 2: Spring Boot (Java/Kotlin)</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Высокая производительность</li>
<li>Отличная поддержка многопоточности</li>
<li>Богатая экосистема enterprise-уровня</li>
<li>Сильная типизация</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Более высокая сложность разработки</li>
<li>Больший overhead для простых CRUD операций</li>
<li>Менее гибкий для быстрого прототипирования</li>
</ul>
<h3 id="Вариант-3-nestjs-nodejstypescript"><a class="header" href="#Вариант-3-nestjs-nodejstypescript"><strong>Вариант 3: NestJS (Node.js/TypeScript)</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Высокая производительность I/O операций</li>
<li>Полная поддержка TypeScript</li>
<li>Модульная архитектура из коробки</li>
<li>Отличная поддержка WebSockets для real-time функций</li>
<li>Легкая интеграция с существующими npm пакетами</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Меньше встроенных возможностей для ML</li>
<li>Требует дополнительной настройки для сложных транзакций</li>
</ul>
<h2 id="Решение-1"><a class="header" href="#Решение-1"><strong>Решение</strong></a></h2>
<p>Выбран Вариант 3: NestJS</p>
<h3 id="Обоснование-выбора"><a class="header" href="#Обоснование-выбора"><strong>Обоснование выбора</strong></a></h3>
<h4 id="1-Соответствие-архитектурным-требованиям-ТЗ"><a class="header" href="#1-Соответствие-архитектурным-требованиям-ТЗ"><strong>1. Соответствие архитектурным требованиям ТЗ</strong></a></h4>
<p>Преимущества для реализации ТЗ:</p>
<ul>
<li>Четкое разделение ответственности между модулями</li>
<li>Легкое тестирование отдельных компонентов</li>
<li>Простота масштабирования и добавления новых функций</li>
</ul>
<h4 id="2-Поддержка-typescript-для-надежной-разработки"><a class="header" href="#2-Поддержка-typescript-для-надежной-разработки"><strong>2. Поддержка TypeScript для надежной разработки</strong></a></h4>
<h4 id="3-Производительность-для-мобильных-клиентов"><a class="header" href="#3-Производительность-для-мобильных-клиентов"><strong>3. Производительность для мобильных клиентов</strong></a></h4>
<p>Оптимизированные эндпоинты для мобильных устройств (кеширование, обработка офлайн-данных)</p>
<h4 id="4-Безопасность-и-соответствие-152-ФЗ"><a class="header" href="#4-Безопасность-и-соответствие-152-ФЗ"><strong>4. Безопасность и соответствие 152-ФЗ</strong></a></h4>
<p>Встроенная поддержка аутентификации и авторизации, Шифрование чувствительных данных и валидация данных</p>
<h4 id="5-Интеграция-с-ИИ-тренером"><a class="header" href="#5-Интеграция-с-ИИ-тренером"><strong>5. Интеграция с ИИ-тренером</strong></a></h4>
<h4 id="6-Оффлайн-синхронизация"><a class="header" href="#6-Оффлайн-синхронизация"><strong>6. Оффлайн-синхронизация</strong></a></h4>
<h2 id="Последствия-1"><a class="header" href="#Последствия-1"><strong>Последствия</strong></a></h2>
<h3 id="Положительные-1"><a class="header" href="#Положительные-1"><strong>Положительные</strong></a></h3>
<ul>
<li>Высокая производительность I/O - критично для мобильных клиентов</li>
<li>Система типов TypeScript - снижение ошибок в сложной бизнес-логике</li>
<li>Модульность - соответствует доменной модели из ТЗ</li>
<li>Быстрая разработка - ускорение time-to-market</li>
<li>Легкая интеграция с внешними сервисами (ИИ, календари, push-уведомления)</li>
</ul>
<h3 id="Отрицательные-1"><a class="header" href="#Отрицательные-1"><strong>Отрицательные</strong></a></h3>
<ul>
<li>Ограничения для сложных ML вычислений - требует вынесения в отдельные сервисы</li>
<li>Меньше enterprise-опыта в команде по сравнению с Spring</li>
<li>Требует дополнительной настройки для сложных транзакций</li>
</ul>
<h3 id="Риски-и-митигация-1"><a class="header" href="#Риски-и-митигация-1"><strong>Риски и митигация</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Риск</th><th style="text-align: left">Вероятность</th><th style="text-align: left">Влияние</th><th style="text-align: left">Митигация</th></tr></thead><tbody>
<tr><td style="text-align: left">Производительность ML вычислений</td><td style="text-align: left">Средняя</td><td style="text-align: left">Высокое</td><td style="text-align: left">Вынос ML в отдельный Python-микросервис</td></tr>
<tr><td style="text-align: left">Сложность транзакций</td><td style="text-align: left">Низкая</td><td style="text-align: left">Среднее</td><td style="text-align: left">Использование паттернов Saga, компенсирующих транзакций</td></tr>
<tr><td style="text-align: left">Кривая обучения</td><td style="text-align: left">Низкая</td><td style="text-align: left">Низкое</td><td style="text-align: left">TypeScript знаком фронтенд-разработчикам</td></tr>
</tbody></table>
</div>
<p>NestJS выбран как оптимальное решение для backend потому что:</p>
<ol>
<li>✅ Полное соответствие требованиям ТЗ по модульной архитектуре</li>
<li>✅ TypeScript гарантирует надежность сложной бизнес-логики тренировок</li>
<li>✅ Высокая производительность I/O критична для мобильных клиентов</li>
<li>✅ Гибкая интеграция с ИИ-сервисами и внешними API</li>
<li>✅ Поддержка real-time функций для будущего расширения</li>
<li>✅ Система безопасности соответствует требованиям 152-ФЗ</li>
</ol>
<p>Данный выбор обеспечивает надежную основу для реализации всех функциональных требований ТЗ, включая сложную логику тренировочных процессов, интеграцию с ИИ-тренером и поддержку оффлайн-режима.</p>
<h3 id="adr-Аутентификация-и-авторизация--jwt--passport-Контекст-Необходимо-обеспечить-безопасную-аутентификацию-пользователей-и-управление-доступом-к-различным-ресурсам-api-Требуется-stateless-решение-масштабируемое-для-мобильных-клиентов"><a class="header" href="#adr-Аутентификация-и-авторизация--jwt--passport-Контекст-Необходимо-обеспечить-безопасную-аутентификацию-пользователей-и-управление-доступом-к-различным-ресурсам-api-Требуется-stateless-решение-масштабируемое-для-мобильных-клиентов"><strong>ADR: Аутентификация и авторизация — JWT + Passport</strong> Контекст: Необходимо обеспечить безопасную аутентификацию пользователей и управление доступом к различным ресурсам API. Требуется stateless решение, масштабируемое для мобильных клиентов.</a></h3>
<p>Решение: Использовать Passport.js стратегии с JWT токенами через <code>@nestjs/passport</code> и <code>@nestjs/jwt</code>.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Stateless: Не требует хранения сессий на сервере</li>
<li>Масштабируемость: Легко масштабируется на несколько инстансов</li>
<li>Безопасность: Подписанные токены защищены от модификации</li>
<li>Стандарт: JWT - отраслевой стандарт для мобильных приложений</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Неотзывчивость: Токены действуют до истечения срока, сложно отозвать</li>
<li>Размер: Токены могут быть большими при хранении много данных</li>
</ul>
</li>
</ul>
<h3 id="adr-Конфигурация-приложения--nestjsconfig-Контекст-Необходимо-управлять-различными-конфигурациями-для-разных-окружений-development-staging-production---базы-данных-api-ключи-настройки-jwt"><a class="header" href="#adr-Конфигурация-приложения--nestjsconfig-Контекст-Необходимо-управлять-различными-конфигурациями-для-разных-окружений-development-staging-production---базы-данных-api-ключи-настройки-jwt"><strong>ADR: Конфигурация приложения — @nestjs/config</strong> Контекст: Необходимо управлять различными конфигурациями для разных окружений (development, staging, production) - базы данных, API ключи, настройки JWT.</a></h3>
<p>Решение: Использовать <code>@nestjs/config</code> модуль на основе dotenv.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Централизация: Все настройки в одном месте</li>
<li>Безопасность: Чувствительные данные не в коде</li>
<li>Окружения: Поддержка разных .env файлов для разных окружений</li>
<li>Валидация: Возможность валидации конфигурации при старте</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Runtime конфигурация: Ошибки конфигурации обнаруживаются только при запуске</li>
</ul>
</li>
</ul>
<h3 id="adr-Логирование--nestjs-logger--winston-Контекст-Требуется-надежная-система-логирования-для-отладки-мониторинга-ошибок-и-аудита-действий-пользователей-Логи-должны-быть-структурированными-и-поддерживать-разные-уровни"><a class="header" href="#adr-Логирование--nestjs-logger--winston-Контекст-Требуется-надежная-система-логирования-для-отладки-мониторинга-ошибок-и-аудита-действий-пользователей-Логи-должны-быть-структурированными-и-поддерживать-разные-уровни"><strong>ADR: Логирование — NestJS Logger + Winston</strong> Контекст: Требуется надежная система логирования для отладки, мониторинга ошибок и аудита действий пользователей. Логи должны быть структурированными и поддерживать разные уровни.</a></h3>
<p>Решение: Использовать встроенный NestJS Logger с возможностью интеграции с Winston для продвинутого логирования.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Структурированные логи: Поддержка JSON формата</li>
<li>Транспорты: Возможность отправки логов в разные места (файлы, console, внешние сервисы)</li>
<li>Производительность: Асинхронное логирование</li>
<li>Интеграция: Легкая интеграция с системами мониторинга</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Настройка: Требует дополнительной настройки для продвинутых сценариев</li>
</ul>
</li>
</ul>
<h3 id="adr-Обработка-ошибок--Глобальный-exception-filter-Контекст-Необходимо-обеспечить-единообразную-обработку-ошибок-во-всем-приложении-возвращать-структурированные-ответы-клиенту-и-логировать-ошибки-для-последующего-анализа"><a class="header" href="#adr-Обработка-ошибок--Глобальный-exception-filter-Контекст-Необходимо-обеспечить-единообразную-обработку-ошибок-во-всем-приложении-возвращать-структурированные-ответы-клиенту-и-логировать-ошибки-для-последующего-анализа"><strong>ADR: Обработка ошибок — Глобальный Exception Filter</strong> Контекст: Необходимо обеспечить единообразную обработку ошибок во всем приложении, возвращать структурированные ответы клиенту и логировать ошибки для последующего анализа.</a></h3>
<p>Решение: Использовать встроенные Exception Filters в NestJS с созданием кастомных фильтров для разных типов ошибок.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Единообразие: Стандартизированные форматы ошибок</li>
<li>Логирование: Автоматическое логирование ошибок</li>
<li>HTTP коды: Корректные HTTP статус коды для разных ошибок</li>
<li>Безопасность: Не раскрывать чувствительную информацию в ошибках</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Глобальность: Некоторые ошибки могут требовать специфичной обработки</li>
</ul>
</li>
</ul>
<h3 id="adr-Кеширование--cache-manager--redis-Контекст-Для-повышения-производительности-необходимо-кешировать-часто-запрашиваемые-данные---списки-упражнений-шаблоны-тренировок-пользовательские-настройки"><a class="header" href="#adr-Кеширование--cache-manager--redis-Контекст-Для-повышения-производительности-необходимо-кешировать-часто-запрашиваемые-данные---списки-упражнений-шаблоны-тренировок-пользовательские-настройки"><strong>ADR: Кеширование — Cache Manager + Redis</strong> Контекст: Для повышения производительности необходимо кешировать часто запрашиваемые данные - списки упражнений, шаблоны тренировок, пользовательские настройки.</a></h3>
<p>Решение: Использовать встроенный <code>@nestjs/cache-manager</code> с Redis как хранилищем кеша.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Производительность: Уменьшение нагрузки на базу данных</li>
<li>Масштабируемость: Redis поддерживает кластеризацию</li>
<li>TTL: Автоматическое истечение кеша</li>
<li>Разные стратегии: Поддержка разных стратегий инвалидации</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Сложность: Дополнительный компонент инфраструктуры</li>
<li>Консистентность: Риск устаревших данных в кеше</li>
</ul>
</li>
</ul>
<h3 id="adr-Очереди-задач--bull-queue-Контекст-Требуется-обработка-фоновых-задач---отправка-email-уведомлений-генерация-отчетов-тяжелые-вычисления-для-ИИ-рекомендаций-которые-не-должны-блокировать-основной-api"><a class="header" href="#adr-Очереди-задач--bull-queue-Контекст-Требуется-обработка-фоновых-задач---отправка-email-уведомлений-генерация-отчетов-тяжелые-вычисления-для-ИИ-рекомендаций-которые-не-должны-блокировать-основной-api"><strong>ADR: Очереди задач — Bull Queue</strong> Контекст: Требуется обработка фоновых задач - отправка email уведомлений, генерация отчетов, тяжелые вычисления для ИИ-рекомендаций, которые не должны блокировать основной API.</a></h3>
<p>Решение: Использовать <code>@nestjs/bull</code> модуль для работы с Bull Queue на основе Redis.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Асинхронность: Не блокирует основной поток</li>
<li>Надежность: Повторные попытки при ошибках</li>
<li>Мониторинг: UI для мониторинга очередей</li>
<li>Приоритеты: Поддержка приоритетов задач</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Redis dependency: Требует запущенного Redis</li>
<li>Сложность: Дополнительная сложность в разработке и отладке</li>
</ul>
</li>
</ul>
<h3 id="adr-Файловая-структура--Модульная-архитектура-Контекст-Необходимо-организовать-код-в-понятную-и-масштабируемую-структуру-соответствующую-бизнес-доменам-приложения"><a class="header" href="#adr-Файловая-структура--Модульная-архитектура-Контекст-Необходимо-организовать-код-в-понятную-и-масштабируемую-структуру-соответствующую-бизнес-доменам-приложения"><strong>ADR: Файловая структура — Модульная архитектура</strong> Контекст: Необходимо организовать код в понятную и масштабируемую структуру, соответствующую бизнес-доменам приложения.</a></h3>
<p>Решение: Использовать модульную архитектуру NestJS, организованную по бизнес-доменам:</p>
<p><code>text</code></p>
<p><code>src/</code><br />
<code>├── users/</code><br />
<code>├── workouts/</code><br />
<code>├── exercises/</code><br />
<code>├── ai-trainer/</code><br />
<code>├── analytics/</code></p>
<p><code>└── shared/</code></p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Сопровождаемость: Легко находить и изменять код</li>
<li>Переиспользование: Модули можно переиспользовать</li>
<li>Тестируемость: Легко тестировать изолированные модули</li>
<li>Onboarding: Новичкам легче разобраться в проекте</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Over-engineering: Риск создания слишком мелких модулей</li>
</ul>
</li>
</ul>
<h3 id="adr-Тестирование--jest--supertest"><a class="header" href="#adr-Тестирование--jest--supertest"><strong>ADR: Тестирование — Jest + Supertest</strong></a></h3>
<p>Контекст: Необходимо обеспечить надежность кода через автоматическое тестирование - unit тесты для бизнес-логики, integration тесты для API, e2e тесты для критических сценариев.</p>
<p>Решение: Использовать встроенную поддержку Jest в NestJS для unit тестов и Supertest для e2e тестирования API.</p>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Интеграция: Отличная интеграция с NestJS</li>
<li>Скорость: Быстрые unit тесты</li>
<li>Mocking: Мощная система мокинга</li>
<li>Coverage: Встроенная поддержка coverage отчетов</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Настройка: Требует времени на настройку тестового окружения</li>
</ul>
</li>
</ul>
<h1 id="adr-БД"><a class="header" href="#adr-БД">ADR БД</a></h1>
<h1 id="adr-Выбор-postgresql-и-redis-для-системы-мобильного-приложения-дневника-тренировок"><a class="header" href="#adr-Выбор-postgresql-и-redis-для-системы-мобильного-приложения-дневника-тренировок"><strong>ADR: Выбор PostgreSQL и Redis для системы мобильного приложения-дневника тренировок</strong></a></h1>
<h2 id="Контекст-2"><a class="header" href="#Контекст-2"><strong>Контекст</strong></a></h2>
<p>Согласно ТЗ требуется разработать систему хранения данных для мобильного приложения-дневника тренировок с ИИ-тренером. Основные требования из ТЗ:</p>
<p>Требования к данным:</p>
<ul>
<li>Сложные связанные данные (пользователи, тренировочные процессы, упражнения, история тренировок)</li>
<li>Транзакционная целостность данных</li>
<li>Поддержка оффлайн-синхронизации</li>
<li>Быстрый доступ к часто запрашиваемым данным</li>
<li>Надежное хранение пользовательских данных</li>
</ul>
<p>Функциональные требования:</p>
<ul>
<li>Управление тренировочными процессами с бизнес-правилами</li>
<li>История тренировок с возможностью анализа</li>
<li>Интеграция с ИИ-тренером</li>
<li>Кэширование рекомендаций и предвычисленных данных</li>
</ul>
<p>Нефункциональные требования:</p>
<ul>
<li>Безопасность: шифрование данных, соответствие 152-ФЗ</li>
<li>Производительность: быстрый отклик для мобильных клиентов</li>
<li>Надежность: не более 1 критической ошибки на 1000 сессий</li>
<li>Масштабируемость: поддержка роста пользовательской базы</li>
</ul>
<h2 id="Рассмотренные-варианты-2"><a class="header" href="#Рассмотренные-варианты-2"><strong>Рассмотренные варианты</strong></a></h2>
<h3 id="Вариант-1-mongodb--redis"><a class="header" href="#Вариант-1-mongodb--redis"><strong>Вариант 1: MongoDB + Redis</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Гибкая схема для эволюции данных</li>
<li>Хорошая горизонтальная масштабируемость</li>
<li>JSON-документы близки к объектной модели</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Слабые гарантии ACID для финансовых операций</li>
<li>Сложности с JOIN-запросами связанных данных</li>
<li>Ограниченная поддержка сложных транзакций</li>
</ul>
<h3 id="Вариант-2-mysql--redis"><a class="header" href="#Вариант-2-mysql--redis"><strong>Вариант 2: MySQL + Redis</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Сильная согласованность данных</li>
<li>Богатая экосистема инструментов</li>
<li>Проверенная надежность</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Менее гибкая схема для изменений</li>
<li>Сложнее работа с JSON данными</li>
<li>Ограничения в производительности для аналитических запросов</li>
</ul>
<h3 id="Вариант-3-postgresql--redis"><a class="header" href="#Вариант-3-postgresql--redis"><strong>Вариант 3: PostgreSQL + Redis</strong></a></h3>
<p>Плюсы:</p>
<ul>
<li>Полная поддержка ACID + расширенные возможности</li>
<li>Отличная поддержка JSON и реляционных данных</li>
<li>Богатый набор типов данных и расширений</li>
<li>Высокая производительность сложных запросов</li>
</ul>
<p>Минусы:</p>
<ul>
<li>Более сложная настройка для горизонтального масштабирования</li>
<li>Требует больше экспертизы для оптимизации</li>
</ul>
<h2 id="Решение-2"><a class="header" href="#Решение-2"><strong>Решение</strong></a></h2>
<p>Выбран Вариант 3: PostgreSQL как основная база данных + Redis как кэш и хранилище сессий</p>
<h3 id="Обоснование-выбора-1"><a class="header" href="#Обоснование-выбора-1"><strong>Обоснование выбора</strong></a></h3>
<h4 id="1-Соответствие-структуре-данных-из-ТЗ"><a class="header" href="#1-Соответствие-структуре-данных-из-ТЗ"><strong>1. Соответствие структуре данных из ТЗ</strong></a></h4>
<h4 id="2-Поддержка-бизнес-правил-на-уровне-базы-данных"><a class="header" href="#2-Поддержка-бизнес-правил-на-уровне-базы-данных"><strong>2. Поддержка бизнес-правил на уровне базы данных</strong></a></h4>
<h4 id="3-Оптимизация-производительности-с-redis"><a class="header" href="#3-Оптимизация-производительности-с-redis"><strong>3. Оптимизация производительности с Redis</strong></a></h4>
<h4 id="4-Оффлайн-синхронизация-и-разрешение-конфликтов"><a class="header" href="#4-Оффлайн-синхронизация-и-разрешение-конфликтов"><strong>4. Оффлайн-синхронизация и разрешение конфликтов</strong></a></h4>
<h4 id="5-Аналитика-и-отчетность"><a class="header" href="#5-Аналитика-и-отчетность"><strong>5. Аналитика и отчетность</strong></a></h4>
<h2 id="Архитектура-данных"><a class="header" href="#Архитектура-данных"><strong>Архитектура данных</strong></a></h2>
<p><code>![][image1]</code></p>
<h2 id="Схемы-использования"><a class="header" href="#Схемы-использования"><strong>Схемы использования</strong></a></h2>
<h3 id="postgresql-для"><a class="header" href="#postgresql-для"><strong>PostgreSQL для:</strong></a></h3>
<ul>
<li>Основные бизнес-данные (пользователи, тренировки, упражнения)</li>
<li>Транзакционные операции (создание тренировочных процессов)</li>
<li>Сложные запросы с JOIN и агрегациями</li>
<li>Отчетность и аналитика прогресса тренировок</li>
<li>История изменений для аудита</li>
</ul>
<h3 id="redis-для"><a class="header" href="#redis-для"><strong>Redis для:</strong></a></h3>
<ul>
<li>Кэширование часто запрашиваемых данных</li>
<li>Сессии пользователей и аутентификация</li>
<li>Rate limiting API эндпоинтов</li>
<li>Временные данные оффлайн-синхронизации</li>
<li>Очереди для фоновых задач (push-уведомления)</li>
</ul>
<h2 id="Последствия-2"><a class="header" href="#Последствия-2"><strong>Последствия</strong></a></h2>
<h3 id="Положительные-2"><a class="header" href="#Положительные-2"><strong>Положительные</strong></a></h3>
<ul>
<li>Гарантии ACID - критично для целостности данных тренировок</li>
<li>Богатые возможности запросов - сложная аналитика прогресса</li>
<li>JSONB поддержка - гибкость для ИИ-рекомендаций</li>
<li>Высокая производительность - быстрый отклик для мобильных клиентов</li>
<li>Надежность - соответствие требованиям ТЗ по надежности</li>
</ul>
<h3 id="Отрицательные-2"><a class="header" href="#Отрицательные-2"><strong>Отрицательные</strong></a></h3>
<ul>
<li>Сложность настройки репликации и кластеризации</li>
<li>Большие overhead для простых операций кэширования</li>
<li>Требует мониторинга и обслуживания</li>
</ul>
<h3 id="Риски-и-митигация-2"><a class="header" href="#Риски-и-митигация-2"><strong>Риски и митигация</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Риск</th><th style="text-align: left">Вероятность</th><th style="text-align: left">Влияние</th><th style="text-align: left">Митигация</th></tr></thead><tbody>
<tr><td style="text-align: left">Потеря данных Redis</td><td style="text-align: left">Средняя</td><td style="text-align: left">Высокое</td><td style="text-align: left">Репликация Redis, персистентность RDB+AOF</td></tr>
<tr><td style="text-align: left">Производительность PostgreSQL</td><td style="text-align: left">Низкая</td><td style="text-align: left">Среднее</td><td style="text-align: left">Индексы, партиционирование, кэширование</td></tr>
<tr><td style="text-align: left">Сложность миграций</td><td style="text-align: left">Низкая</td><td style="text-align: left">Среднее</td><td style="text-align: left">Использование инструментов миграции (TypeORM)</td></tr>
</tbody></table>
</div>
<h2 id="Заключение-1"><a class="header" href="#Заключение-1"><strong>Заключение</strong></a></h2>
<p>PostgreSQL + Redis выбран как оптимальная комбинация потому что:</p>
<ol>
<li>✅ PostgreSQL обеспечивает надежность для критичных данных тренировок</li>
<li>✅ Поддержка сложных бизнес-правил на уровне БД (ограничения, триггеры)</li>
<li>✅ JSONB для гибкости ИИ-рекомендаций и метаданных</li>
<li>✅ Redis для производительности кэширования и сессий</li>
<li>✅ Полное соответствие ТЗ по безопасности и надежности</li>
<li>✅ Масштабируемость для роста пользовательской базы</li>
</ol>
<p>Данная комбинация обеспечивает оптимальный баланс между надежностью хранения основных данных и производительностью доступа к часто используемым данным, что критически важно для мобильного приложения с требованиями оффлайн-работы и сложной бизнес-логикой тренировочных процессов.</p>
<h1 id="adr-нейросеть"><a class="header" href="#adr-нейросеть">ADR нейросеть</a></h1>
<h3 id="Модель-нейронной-сети-для-генерации-тренировок--transformer-based-hybrid-recommendation-system-Контекст-Требуется-разработать-ИИ-тренера-способного-генерировать-персонализированные-тренировочные-программы-на-основе-множества-факторов-цели-пользователя-опыта-доступного-оборудования-места-тренировок-исторических-данных-и-фитнес-принципов-Модель-должна-учитывать-сложные-взаимосвязи-между-упражнениями-и-адаптировать-нагрузки"><a class="header" href="#Модель-нейронной-сети-для-генерации-тренировок--transformer-based-hybrid-recommendation-system-Контекст-Требуется-разработать-ИИ-тренера-способного-генерировать-персонализированные-тренировочные-программы-на-основе-множества-факторов-цели-пользователя-опыта-доступного-оборудования-места-тренировок-исторических-данных-и-фитнес-принципов-Модель-должна-учитывать-сложные-взаимосвязи-между-упражнениями-и-адаптировать-нагрузки"><strong>Модель нейронной сети для генерации тренировок — Transformer-based Hybrid Recommendation System</strong> Контекст: Требуется разработать ИИ-тренера, способного генерировать персонализированные тренировочные программы на основе множества факторов: цели пользователя, опыта, доступного оборудования, места тренировок, исторических данных и фитнес-принципов. Модель должна учитывать сложные взаимосвязи между упражнениями и адаптировать нагрузки.</a></h3>
<p>Решение: Использовать гибридную архитектуру на основе Transformer с элементами рекомендательных систем и генеративных моделей.</p>
<p>Архитектура модели:</p>
<p><code>text</code></p>
<p><code>Input Layer (Multiple Embeddings)</code><br />
<code>├── User Features Embedding</code><br />
<code>├── Exercise Features Embedding</code><br />
<code>├── Historical Data Embedding</code><br />
<code>└── Fitness Principles Embedding</code><br />
<code>│</code><br />
<code>▼</code><br />
<code>Multi-Head Attention Layer</code><br />
<code>├── Exercise Compatibility Attention</code><br />
<code>├── Muscle Group Balance Attention</code><br />
<code>└── Progressive Overload Attention</code><br />
<code>│</code><br />
<code>▼</code><br />
<code>Transformer Encoder Blocks (4-8 layers)</code><br />
<code>├── Self-Attention Mechanisms</code><br />
<code>├── Feed-Forward Networks</code><br />
<code>└── Layer Normalization</code><br />
<code>│</code><br />
<code>▼</code><br />
<code>Task-Specific Heads</code><br />
<code>├── Exercise Sequence Generator</code><br />
<code>├── Set/Rep Recommender</code><br />
<code>├── Rest Time Predictor</code></p>
<p><code>└── Difficulty Adjuster</code></p>
<p>Компоненты решения:</p>
<ol>
<li>Input Embeddings:
<ul>
<li>User Embedding: цель (масса/похудение/тонус) × опыт × возраст × пол</li>
<li>Context Embedding: место (дом/зал/улица) × оборудование × время</li>
<li>Exercise Embedding: мышцы-цели × тип × сложность × инвентарь</li>
<li>Temporal Embedding: дни недели × частота × прогрессия</li>
</ul>
</li>
<li>Attention Mechanisms:
<ul>
<li>Muscle Group Balancing: предотвращает перетренированность одной группы</li>
<li>Exercise Compatibility: учитывает синергию между упражнениями</li>
<li>Recovery Awareness: учитывает время восстановления мышц</li>
</ul>
</li>
<li>Output Heads:
<ul>
<li>Sequence Generation: порядок упражнений (Encoder-Decoder)</li>
<li>Parameters Prediction: подходы/повторения/вес (Regression)</li>
<li>Adaptation Logic: корректировка на основе feedback (RL)</li>
</ul>
</li>
</ol>
<p>Обоснование выбора:</p>
<ol>
<li>Transformer Architecture:
<ul>
<li>Обрабатывает переменную длину последовательностей упражнений</li>
<li>Улавливает сложные зависимости между упражнениями</li>
<li>Масштабируется для больших каталогов упражнений</li>
</ul>
</li>
<li>Multi-Task Learning:
<ul>
<li>Совместное обучение генерации и параметризации</li>
<li>Улучшение обобщения за счет связанных задач</li>
<li>Эффективное использование данных</li>
</ul>
</li>
<li>Hybrid Approach:
<ul>
<li>Content-Based: похожесть упражнений по характеристикам</li>
<li>Collaborative Filtering: паттерны успешных тренировок у похожих пользователей</li>
<li>Knowledge-Based: соблюдение фитнес-принципов (прогрессия, баланс)</li>
</ul>
</li>
</ol>
<p>Данные для обучения:</p>
<ul>
<li>Исторические данные тренировок пользователей</li>
<li>Экспертные программы от фитнес-тренеров</li>
<li>Научные исследования по физиологии упражнений</li>
<li>Feedback данных (успешность/пропуски/сложность)</li>
</ul>
<p>Последствия:</p>
<ul>
<li>Плюсы:
<ul>
<li>Высокая персонализация: Учитывает все аспекты пользователя и контекста</li>
<li>Баланс и безопасность: Встроенные механизмы предотвращения дисбаланса</li>
<li>Адаптивность: Может перестраивать рекомендации на основе обратной связи</li>
<li>Объяснимость: Attention weights показывают, почему выбраны определенные упражнения</li>
<li>Масштабируемость: Легко добавлять новые упражнения и параметры</li>
</ul>
</li>
<li>Минусы:
<ul>
<li>Сложность реализации: Требует глубоких знаний в ML и фитнесе</li>
<li>Вычислительная стоимость: Большая модель требует значительных ресурсов</li>
<li>Data Hunger: Требуется много размеченных данных для качественного обучения</li>
<li>Валидация: Сложно автоматически оценивать качество генерируемых программ</li>
</ul>
</li>
</ul>
<p>Эта архитектура обеспечивает баланс между современными ML-подходами и domain knowledge фитнеса, создавая интеллектуального и безопасного ИИ-тренера.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="article.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="article.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
